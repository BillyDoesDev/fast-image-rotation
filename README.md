# Fast Parallel Image Rotation Algorithm

**Abstract**</br>
This project aims to effectively parallelize 

## Setup and building

- ~~Install OpenCV (this is only temporary, since we'll use this to read and write images only for now, and later on will switch to [Halide](http://halide-lang.org))~~
    ```sh
    # the following instructions are for arch
    # packages and procedures may vary
    sudo pacman -Sy glew fmt vtk hdf5 opencv

    # optionally install `zlib` for Halide in case your system doesn't already have it
    ```
    Aditionally, also install the `zlib`, `png` and `jpg` headers accordingly, should you need them. They come pre-installed and configured on Arch based distros, however, you may have to install them on a debian based system (package name may vary).
    ```sh
    sudo apt update && sudo apt install -y libpng-dev libjpg-dev zlib1g zlib1g-dev
    ```

- Clone this repo, download and extract the [binary release of Halide](https://github.com/halide/Halide/releases) for your system and place it in the current working directory.
    > **Note:** You may have to modify the `CMakeLists.txt` file accordingly.

    ```make
    # Add include directories for Halide
    include_directories(${PROJECT_SOURCE_DIR}/Halide-17.0.1-x86-64-linux/include)
    ```
    Also, make sure you have the `zlib` and `OpenCV` binaries in your path.

- Build the thing
    ```sh
    mkdir build
    cd build
    cmake ..
    make
    ```

## How it works

**Stage 1: The naive rotation matrix approach**

- First, we calculate the new dimensions of the image to fit the rotation.</br>
<img src="https://raw.githubusercontent.com/BillyDoesDev/fast-image-rotation/main/assets/resized_image.png" /></br>
*the figure above represents the new size of the image after rotation by an angle $\theta$*

- Next, we decide on a centre for rotation (in this case, the centre of the image $(cx, xy)$), and apply the rotation matrix for each pixel coordinate, $(x, y)$ of the image

    ![equation](https://latex.codecogs.com/svg.image?%5Clarge%20%7B%5Ccolor%7BGray%7D%5Cbegin%7Bbmatrix%7Dx'%5C%5Cy'%5Cend%7Bbmatrix%7D=%5Cbegin%7Bbmatrix%7Dx-cx%5C%5Cy-cy%5Cend%7Bbmatrix%7D*%5Cbegin%7Bbmatrix%7Dcos(%5Ctheta)&-sin(%5Ctheta)%5C%5Csin(%5Ctheta)&cos(%5Ctheta)%5Cend%7Bbmatrix%7D%7D)

    <!-- because for some stupid reason github does not support latex -->

    <!-- $$\begin{bmatrix}
    x'\\ 
    y'
    \end{bmatrix} = \begin{bmatrix}
    x - cx\\ 
    y - cy
    \end{bmatrix} * \begin{bmatrix}
    cos(\theta) & -sin(\theta)\\
    sin(\theta) & cos(\theta)
    \end{bmatrix}$$ -->

    Assuming the centre of rotation of the new image is $(cx', cy')$, the final new coordinates are:

    ![equation](https://latex.codecogs.com/svg.image?%5Clarge%20%7B%5Ccolor%7BGray%7D%5Cbegin%7Bbmatrix%7Dx'%5C%5Cy'%5Cend%7Bbmatrix%7D=%5Cbegin%7Bbmatrix%7Dx'&plus;cx'%5C%5Cy'&plus;cy'%5Cend%7Bbmatrix%7D%7D)

    <!-- $$\begin{bmatrix}
    x'\\ 
    y'
    \end{bmatrix} = \begin{bmatrix}
    x' + cx'\\ 
    y' + cy'
    \end{bmatrix}$$ -->

- Finally, we do `pixel_val_at(x', y') = pixel_val_at(x, y)`


**Stage 2: Implementation in Halide**

- The necessary conversion was performed in `./parallel_rotation.cpp`, with minimal optimization. </br>
Here is the pseudocode generated by Halide for the rotation function:

    ```
    for c:
        parallel y:
        for x.x:
            vectorized x.v0 in [0, 7]:
            rotated(...) = ...
    ```

    In my tests, this program performed about **2.63 times *slower*** than the existing OpenCV implementation, both with and without using optimizations.

    PS: I will upload a detailed benchmark score later on.


## What next?

The fact that the Halide implementation performed significantly slower than the previous serial approach suggests one of two things (personal hunch), either:

-  The overhead of managing threads and synchronization can sometimes outweigh the benefits of parallel execution, especially for relatively simple computations, or...
-  The algorithm being used needs modification, in order to leverage Halide's capabilities - perhaps work on an algorithm that makes use of overlapping pixel operations, etc, instead of simply trying to parallelize the workload.